!vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvC
!                                                                      C
!  Module name: GET_MSH_DATA                                           C
!  Purpose: reads face vertices and normal vectors from an MSH file    C
!           (generated by Gambit). After reading the geometry, the     C
!           data is converted into same format as STL and the          C
!           pre-processing switches to STL procedure                   C
!                                                                      C
!  Author: Jeff Dietiker                              Date: 30-JAN-09  C
!  Reviewer:                                          Date: **-***-**  C
!                                                                      C
!  Revision Number:                                                    C
!  Purpose:                                                            C
!  Author:                                            Date: dd-mmm-yy  C
!  Reviewer:                                          Date: dd-mmm-yy  C
!                                                                      C
!  Literature/Document References:                                     C
!                                                                      C
!  Variables referenced:                                               C
!                                                                      C
!  Variables modified:                                                 C
!                                                                      C
!  Local variables:                                                    C
!                                                                      C
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^C
!
      SUBROUTINE GET_MSH_DATA

!-----------------------------------------------
!   M o d u l e s
!-----------------------------------------------

      USE bc
      USE compar
      USE constant
      USE exit, only: mfix_exit
      USE fldvar
      USE funits
      USE mpi_utility
      USE param
      USE param1
      USE physprop
      USE progress_bar
      USE quadric
      USE run
      USE rxns
      USE scalars
      USE stl
      USE vtk

      IMPLICIT NONE

      INTEGER,PARAMETER :: MAX_POINTS = 10000000    ! Currently limited to 10 Million, increase if needed
      INTEGER,PARAMETER :: MAX_ZONES  = 1000        ! Currently limited to 1,000     , increase if needed

      INTEGER ::I,D,NN,NF

      INTEGER   :: GRID_DIMENSION, N_POINTS,N_FACES,N_FACE_ZONES
      INTEGER   :: ZONE,ZONE_ID,N1,N2
      INTEGER   :: PPFACE

      LOGICAL :: ALL_POINTS_READ,ALL_FACES_READ

      INTEGER, ALLOCATABLE, DIMENSION(:,:) ::POINT_ZONE_INFO,FACE_ZONE_INFO
      DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) :: POINT_COORDS

      CHARACTER(LEN=18), ALLOCATABLE, DIMENSION(:,:) :: BC_LABEL_TEXT

      LOGICAL, ALLOCATABLE, DIMENSION(:) :: BC_ASSIGNED

      CHARACTER(LEN=18),DIMENSION(10) :: BUFF_CHAR

      INTEGER :: P1,P2,P3,P4
      DOUBLE PRECISION, DIMENSION(3) :: NORMAL, VECTMP, VECTMP2
      DOUBLE PRECISION ::NORM

      DOUBLE PRECISION ::v1x,v1y,v1z
      DOUBLE PRECISION ::v2x,v2y,v2z
      DOUBLE PRECISION ::v3x,v3y,v3z
      DOUBLE PRECISION ::ABSTRANS

      LOGICAL :: PRESENT

      INTEGER :: BC_LABELS_TO_READ, BC_LABELS_READ,NFZ,ZID,L2
      INTEGER :: N_BC_IGNORED
      INTEGER :: N_QUAD2TRI

      ALLOCATE(POINT_COORDS(3,MAX_POINTS))
      ALLOCATE(POINT_ZONE_INFO(MAX_ZONES,3))
      ALLOCATE(FACE_ZONE_INFO(MAX_ZONES,3))
      ALLOCATE(BC_LABEL_TEXT(MAX_ZONES,2))
      ALLOCATE(BC_ASSIGNED(MAX_ZONES))

      WRITE(*,2000) 'READING geometry from geometry.msh...'

      INQUIRE(FILE='geometry.msh',EXIST=PRESENT)
      IF(.NOT.PRESENT) THEN
         IF(MyPE == PE_IO) THEN
            WRITE(*,"('(PE ',I3,'): input data file, ',A11,' is missing: run aborted')") &
            myPE,'geometry.msh'
         ENDIF
         CALL MFIX_EXIT(MYPE)
      ENDIF
!
!
!     OPEN geometry.msh ASCII FILE
!
      OPEN(UNIT=333, FILE='geometry.msh', STATUS='OLD', ERR=910,CONVERT='BIG_ENDIAN')

      IF(MyPE == PE_IO) WRITE(*,2000)'MSH file opened. Starting reading data...'

      OPEN(UNIT=444, FILE='checkgeometry.stl',CONVERT='BIG_ENDIAN')
      write(444,*)'solid vcg'

      CALL SKIP(333,3)

! Reading grid dimension
      READ(333,*) (BUFF_CHAR(I),I=1,2)

      CALL TEXT_HEX2INT(BUFF_CHAR(2)(1:1),GRID_DIMENSION)

      CALL SKIP(333,1)

! Reading Points

      READ(333,*) (BUFF_CHAR(I),I=1,4)

      CALL TEXT_HEX2INT(BUFF_CHAR(4),N_POINTS)

      ZONE = 1
      ALL_POINTS_READ = .FALSE.

      DO WHILE(.NOT.ALL_POINTS_READ)

         READ(333,*) (BUFF_CHAR(I),I=1,4)
         CALL TEXT_HEX2INT(BUFF_CHAR(2),ZONE_ID)
         CALL TEXT_HEX2INT(BUFF_CHAR(3),N1)
         CALL TEXT_HEX2INT(BUFF_CHAR(4),N2)

         POINT_ZONE_INFO(ZONE,1) = ZONE_ID
         POINT_ZONE_INFO(ZONE,2) = N1
         POINT_ZONE_INFO(ZONE,3) = N2

         DO NN = N1,N2
            READ(333,*) (POINT_COORDS(D,NN),D=1,GRID_DIMENSION)
         ENDDO

         IF(N2/=N_POINTS) THEN
            ZONE = ZONE + 1
         ELSE
            ALL_POINTS_READ = .TRUE.
!            WRITE(*,*)' ALL POINTS READ SUCCESSFULLY.'
          ENDIF

      ENDDO

      CALL SKIP(333,3)

! Reading FACES

      READ(333,*) (BUFF_CHAR(I),I=1,4)

      CALL TEXT_HEX2INT(BUFF_CHAR(3),N_FACES)
!      WRITE(*,*)' READING FACES ...'

      ZONE = 1
      ALL_FACES_READ = .FALSE.

      BC_LABELS_TO_READ = 0
      N_BC_IGNORED = 0
      NF=0
      N_QUAD2TRI=0

      DO WHILE(.NOT.ALL_FACES_READ)

         READ(333,*) (BUFF_CHAR(I),I=1,4)

         CALL TEXT_HEX2INT(BUFF_CHAR(1)(5:),ZONE_ID)
         CALL TEXT_HEX2INT(BUFF_CHAR(2),N1)
         CALL TEXT_HEX2INT(BUFF_CHAR(3),N2)

         FACE_ZONE_INFO(ZONE,1) = ZONE_ID
         FACE_ZONE_INFO(ZONE,2) = N1
         FACE_ZONE_INFO(ZONE,3) = N2

         BC_LABELS_TO_READ = BC_LABELS_TO_READ + 1

         IF(IS_CG(BC_TYPE_ENUM(ZONE_ID))) THEN

            DO NN = N1,N2
               READ(333,*)PPFACE
               IF(PPFACE<3.OR.PPFACE>4) THEN
                  IF(MyPE == PE_IO) WRITE(*,*)PPFACE, 'POINTS PER FACE. EACH FACE MUST HAVE 3 OR 4 POINTS.'
                  CALL MFIX_EXIT(MYPE)

               ELSEIF(PPFACE==3) THEN
                  BACKSPACE(333)
                  READ(333,*) (BUFF_CHAR(I),I=1,4)
                  CALL TEXT_HEX2INT(BUFF_CHAR(2),P1)
                  CALL TEXT_HEX2INT(BUFF_CHAR(3),P2)
                  CALL TEXT_HEX2INT(BUFF_CHAR(4),P3)

                  V1x = POINT_COORDS(1,P1)
                  V1y = POINT_COORDS(2,P1)
                  V1z = POINT_COORDS(3,P1)

                  V2x = POINT_COORDS(1,P2)
                  V2y = POINT_COORDS(2,P2)
                  V2z = POINT_COORDS(3,P2)

                  V3x = POINT_COORDS(1,P3)
                  V3y = POINT_COORDS(2,P3)
                  V3z = POINT_COORDS(3,P3)

                  VECTMP  = POINT_COORDS(:,P2)-POINT_COORDS(:,P1)
                  VECTMP2 = POINT_COORDS(:,P3)-POINT_COORDS(:,P1)
                  NORMAL = CROSS_PRODUCT(VECTMP,VECTMP2)

                  NORM = sqrt(dot_product(normal(:),normal(:)))
                  NORMAL = NORMAL / NORM

                  NF = NF + 1

                  ! Save and Reverse unit vector if needed (this will switch fluid and blocked cells)
                  NORM_FACE(:,NF) = NORMAL*OUT_MSH_VALUE


                  VERTEX(1,1,NF) = SCALE_MSH*V1x + TX_MSH
                  VERTEX(1,2,NF) = SCALE_MSH*V1y + TY_MSH
                  VERTEX(1,3,NF) = SCALE_MSH*V1z + TZ_MSH

                  VERTEX(2,1,NF) = SCALE_MSH*V2x + TX_MSH
                  VERTEX(2,2,NF) = SCALE_MSH*V2y + TY_MSH
                  VERTEX(2,3,NF) = SCALE_MSH*V2z + TZ_MSH

                  VERTEX(3,1,NF) = SCALE_MSH*V3x + TX_MSH
                  VERTEX(3,2,NF) = SCALE_MSH*V3y + TY_MSH
                  VERTEX(3,3,NF) = SCALE_MSH*V3z + TZ_MSH

                  BC_ID_STL_FACE(NF) = ZONE_ID


                  write(444,*) '   facet normal ', NORM_FACE(:,NF)
                  write(444,*) '      outer loop'
                  write(444,*) '         vertex ', VERTEX(1,1:3,NF)
                  write(444,*) '         vertex ', VERTEX(2,1:3,NF)
                  write(444,*) '         vertex ', VERTEX(3,1:3,NF)
                  write(444,*) '      endloop'
                  write(444,*) '   endfacet'

               ELSEIF(PPFACE==4) THEN
                  BACKSPACE(333)
                  READ(333,*) (BUFF_CHAR(I),I=1,5)
                  CALL TEXT_HEX2INT(BUFF_CHAR(2),P1)
                  CALL TEXT_HEX2INT(BUFF_CHAR(3),P2)
                  CALL TEXT_HEX2INT(BUFF_CHAR(4),P3)
                  CALL TEXT_HEX2INT(BUFF_CHAR(5),P4)

                  N_QUAD2TRI = N_QUAD2TRI + 1

! Splitting Quad face 1-2-3-4 into two triangles 1-2-3 and 1-3-4

! First triangle 1-2-3

                  V1x = POINT_COORDS(1,P1)
                  V1y = POINT_COORDS(2,P1)
                  V1z = POINT_COORDS(3,P1)

                  V2x = POINT_COORDS(1,P2)
                  V2y = POINT_COORDS(2,P2)
                  V2z = POINT_COORDS(3,P2)

                  V3x = POINT_COORDS(1,P3)
                  V3y = POINT_COORDS(2,P3)
                  V3z = POINT_COORDS(3,P3)

                  VECTMP  = POINT_COORDS(:,P2)-POINT_COORDS(:,P1)
                  VECTMP2 = POINT_COORDS(:,P3)-POINT_COORDS(:,P1)
                  NORMAL = CROSS_PRODUCT(VECTMP,VECTMP2)

                  NORM = sqrt(dot_product(normal(:),normal(:)))
                  NORMAL = NORMAL / NORM

                  NF = NF + 1

                  ! Save and Reverse unit vector if needed (this will switch fluid and blocked cells)
                  NORM_FACE(:,NF) = NORMAL*OUT_MSH_VALUE

                  VERTEX(1,1,NF) = SCALE_MSH*V1x + TX_MSH
                  VERTEX(1,2,NF) = SCALE_MSH*V1y + TY_MSH
                  VERTEX(1,3,NF) = SCALE_MSH*V1z + TZ_MSH

                  VERTEX(2,1,NF) = SCALE_MSH*V2x + TX_MSH
                  VERTEX(2,2,NF) = SCALE_MSH*V2y + TY_MSH
                  VERTEX(2,3,NF) = SCALE_MSH*V2z + TZ_MSH

                  VERTEX(3,1,NF) = SCALE_MSH*V3x + TX_MSH
                  VERTEX(3,2,NF) = SCALE_MSH*V3y + TY_MSH
                  VERTEX(3,3,NF) = SCALE_MSH*V3z + TZ_MSH

                  BC_ID_STL_FACE(NF) = ZONE_ID


                  write(444,*) '   facet normal ', NORM_FACE(:,NF)
                  write(444,*) '      outer loop'
                  write(444,*) '         vertex ', VERTEX(1,1:3,NF)
                  write(444,*) '         vertex ', VERTEX(2,1:3,NF)
                  write(444,*) '         vertex ', VERTEX(3,1:3,NF)
                  write(444,*) '      endloop'
                  write(444,*)'   endfacet'

! Second triangle 1-3-4

                  V1x = POINT_COORDS(1,P1)
                  V1y = POINT_COORDS(2,P1)
                  V1z = POINT_COORDS(3,P1)

                  V2x = POINT_COORDS(1,P3)
                  V2y = POINT_COORDS(2,P3)
                  V2z = POINT_COORDS(3,P3)

                  V3x = POINT_COORDS(1,P4)
                  V3y = POINT_COORDS(2,P4)
                  V3z = POINT_COORDS(3,P4)

                  VECTMP  = POINT_COORDS(:,P3)-POINT_COORDS(:,P1)
                  VECTMP2 = POINT_COORDS(:,P4)-POINT_COORDS(:,P1)
                  NORMAL = CROSS_PRODUCT(VECTMP,VECTMP2)

                  NORM = sqrt(dot_product(normal(:),normal(:)))
                  NORMAL = NORMAL / NORM

                  NF = NF + 1

                  ! Save and Reverse unit vector if needed (this will switch fluid and blocked cells)
                  NORM_FACE(:,NF) = NORMAL*OUT_MSH_VALUE

                  VERTEX(1,1,NF) = SCALE_MSH*V1x + TX_MSH
                  VERTEX(1,2,NF) = SCALE_MSH*V1y + TY_MSH
                  VERTEX(1,3,NF) = SCALE_MSH*V1z + TZ_MSH

                  VERTEX(2,1,NF) = SCALE_MSH*V2x + TX_MSH
                  VERTEX(2,2,NF) = SCALE_MSH*V2y + TY_MSH
                  VERTEX(2,3,NF) = SCALE_MSH*V2z + TZ_MSH

                  VERTEX(3,1,NF) = SCALE_MSH*V3x + TX_MSH
                  VERTEX(3,2,NF) = SCALE_MSH*V3y + TY_MSH
                  VERTEX(3,3,NF) = SCALE_MSH*V3z + TZ_MSH

                  BC_ID_STL_FACE(NF) = ZONE_ID

                  write(444,*) '   facet normal ', NORM_FACE(:,NF)
                  write(444,*) '      outer loop'
                  write(444,*) '         vertex ', VERTEX(1,1:3,NF)
                  write(444,*) '         vertex ', VERTEX(2,1:3,NF)
                  write(444,*) '         vertex ', VERTEX(3,1:3,NF)
                  write(444,*) '      endloop'
                  write(444,*)'   endfacet'

               ENDIF
            ENDDO

         ELSE
            N_BC_IGNORED = N_BC_IGNORED + 1
!            WRITE(*,*)'BOUNDARY CONDITION FOR ZONE',ZONE_ID,' IS NOT DEFINED.'
!            WRITE(*,*)'THIS ZONE IS IGNORED'
            CALL SKIP(333,N2-N1+1)
         ENDIF


         IF(N2/=N_FACES) THEN
            ZONE = ZONE + 1
            ALL_FACES_READ = .FALSE.
            CALL SKIP(333,1)
         ELSE
            ALL_FACES_READ = .TRUE.
!            WRITE(*,*)' ALL FACES READ SUCCESSFULLY.'
            N_FACE_ZONES = ZONE
          ENDIF

      ENDDO

      write(444,*)'endsolid vcg'

      close(444)

      IF(MyPE == PE_IO) THEN
         WRITE(*,*) ' The file check_geometry.stl was sucessfully written.'
         WRITE(*,*) ' This is the equivalent of geometry.msh in STL format,'
         WRITE(*,*) ' and is provided for convenience (it is not used).'
      ENDIF

! Reading Boundary condition labels

      BC_LABELS_READ = 0
      BC_ASSIGNED = .FALSE.


      DO WHILE(BC_LABELS_READ < BC_LABELS_TO_READ)

         READ(333,*) BUFF_CHAR(1)

         IF(BUFF_CHAR(1)=='(45') THEN
            BACKSPACE(333)
            READ(333,*) (BUFF_CHAR(I),I=1,4)

            CALL TEXT_DEC2INT(BUFF_CHAR(2),ZONE_ID)

            DO ZONE = 1,N_FACE_ZONES
               IF(FACE_ZONE_INFO(ZONE,1)==ZONE_ID) THEN
                  BC_LABELS_READ = BC_LABELS_READ + 1
                  BC_LABEL_TEXT(ZONE,1) = TRIM(BUFF_CHAR(3))
                  BC_LABEL_TEXT(ZONE,2) = TRIM(BUFF_CHAR(4))
                  IF(IS_CG(BC_TYPE_ENUM(ZONE_ID))) THEN
                     BC_ASSIGNED(ZONE) = .TRUE.
                  ENDIF
               ENDIF
            ENDDO

         ENDIF
      ENDDO

      IF(MyPE == PE_IO) THEN

         WRITE(*,*)' Summary of data read from geometry.msh file:'
         WRITE(*,*)'======================================================================'
         WRITE(*,*)' DIMENSION   POINTS       FACES       ZONES'
         WRITE(*,*)'======================================================================'

         WRITE(*,1020) GRID_DIMENSION,N_POINTS,N_FACES,N_FACE_ZONES
         WRITE(*,*)''
         WRITE(*,*)' BOUNDARY CONDITION DETECTED (INFO EXTRACTED FROM .MSH FILE):'
         WRITE(*,*)'======================================================================'
         WRITE(*,*)'  ZONE  BC_TYPE(MFIX)  FACES   BC_TYPE(GAMBIT)      BC LABEL'
         WRITE(*,*)'======================================================================'

         N_FACES = 0
         DO ZONE = 1,N_FACE_ZONES
            IF(BC_ASSIGNED(ZONE)) THEN
               ZID = FACE_ZONE_INFO(ZONE,1)
               NFZ = FACE_ZONE_INFO(ZONE,3)-FACE_ZONE_INFO(ZONE,2) + 1
               N_FACES = N_FACES + NFZ
               L2=LEN(TRIM(BC_LABEL_TEXT(ZONE,2)))-4
               WRITE(*,1000) ZID,BC_TYPE_ENUM(ZID),NFZ,BC_LABEL_TEXT(ZONE,1),BC_LABEL_TEXT(ZONE,2)(1:L2)
            ENDIF
         ENDDO

         WRITE(*,*)''

         DO ZONE = 1,N_FACE_ZONES
            IF(.NOT.BC_ASSIGNED(ZONE)) THEN
               ZID = FACE_ZONE_INFO(ZONE,1)
               NFZ = FACE_ZONE_INFO(ZONE,3)-FACE_ZONE_INFO(ZONE,2) + 1
               L2=LEN(TRIM(BC_LABEL_TEXT(ZONE,2)))-4
               WRITE(*,1000) ZID,'NOT USED',NFZ,BC_LABEL_TEXT(ZONE,1),BC_LABEL_TEXT(ZONE,2)(1:L2)
            ENDIF
         ENDDO

         WRITE(*,*)'======================================================================'
         WRITE(*,*)' PLEASE VERIFY THAT BOUNDARY CONDITIONS ARE CORRECTLY ASSIGNED.'
         WRITE(*,*)' MODIFY BC_TYPE IN mfix.dat IF NECESSARY.'
         WRITE(*,*)''

      ENDIF


      XMIN_MSH = MINVAL(VERTEX(:,1,1:N_FACES))
      XMAX_MSH = MAXVAL(VERTEX(:,1,1:N_FACES))
      YMIN_MSH = MINVAL(VERTEX(:,2,1:N_FACES))
      YMAX_MSH = MAXVAL(VERTEX(:,2,1:N_FACES))
      ZMIN_MSH = MINVAL(VERTEX(:,3,1:N_FACES))
      ZMAX_MSH = MAXVAL(VERTEX(:,3,1:N_FACES))

      IF(MyPE == PE_IO) THEN
         WRITE(*,2000)'MSH file successfully read.'
         WRITE(*,*)' Total number of faces used as boundary faces =',N_FACES
         IF(N_QUAD2TRI>0) WRITE(*,*)' Number of quad faces split into triangles    =',N_QUAD2TRI


         WRITE(*,*)' RANGE OF MSH FILE:'
         IF(SCALE_MSH/=ONE) THEN
            WRITE(*,5000)' AFTER SCALING BY A FACTOR OF ',SCALE_MSH
         ENDIF
         ABSTRANS = dabs(TX_MSH)+dabs(TY_MSH)+dabs(TZ_MSH)
         IF(ABSTRANS>TOL_MSH) THEN
            WRITE(*,3000)' AFTER TRANSLATION OF (X,Y,Z)=',TX_MSH,TY_MSH,TZ_MSH
         ENDIF
         WRITE(*,4000)'X-RANGE = ', XMIN_MSH,XMAX_MSH
         WRITE(*,4000)'Y-RANGE = ', YMIN_MSH,YMAX_MSH
         WRITE(*,4000)'Z-RANGE = ', ZMIN_MSH,ZMAX_MSH
         WRITE(*,4000)''
      ENDIF

      XMIN_MSH = XMIN_MSH - 10.0*TOL_MSH
      XMAX_MSH = XMAX_MSH + 10.0*TOL_MSH
      YMIN_MSH = YMIN_MSH - 10.0*TOL_MSH
      YMAX_MSH = YMAX_MSH + 10.0*TOL_MSH
      ZMIN_MSH = ZMIN_MSH - 10.0*TOL_MSH
      ZMAX_MSH = ZMAX_MSH + 10.0*TOL_MSH

      N_FACETS = N_FACES

      N_FACETS = NF

      XMIN_STL = XMIN_MSH
      XMAX_STL = XMAX_MSH
      YMIN_STL = YMIN_MSH
      YMAX_STL = YMAX_MSH
      ZMIN_STL = ZMIN_MSH
      ZMAX_STL = ZMAX_MSH

      OUT_STL_VALUE = OUT_MSH_VALUE

      CLOSE(333)

      OPEN(UNIT=444, FILE='msgeometry.stl',CONVERT='BIG_ENDIAN')

         DO ZONE = 1,N_FACE_ZONES
            IF(BC_ASSIGNED(ZONE)) THEN
               ZID = FACE_ZONE_INFO(ZONE,1)
               L2=LEN(TRIM(BC_LABEL_TEXT(ZONE,2)))-4
!               WRITE(*,1000) ZID,BC_TYPE(ZID),NFZ,BC_LABEL_TEXT(ZONE,1),BC_LABEL_TEXT(ZONE,2)(1:L2)
               print*,'=======>  Zone ID= ', ZID,BC_LABEL_TEXT(ZONE,2)(1:L2)
               write(444,6000) 'solid', BC_LABEL_TEXT(ZONE,2)(1:L2),ZID
               DO NF=1,N_FACETS
                  IF(BC_ID_STL_FACE(NF) == ZID) THEN

                  write(444,*) '   facet normal ', NORM_FACE(:,NF)
                  write(444,*) '      outer loop'
                  write(444,*) '         vertex ', VERTEX(1,1:3,NF)
                  write(444,*) '         vertex ', VERTEX(2,1:3,NF)
                  write(444,*) '         vertex ', VERTEX(3,1:3,NF)
                  write(444,*) '      endloop'
                  write(444,*)'   endfacet'


                  ENDIF
               ENDDO

               write(444,6000) 'endsolid', BC_LABEL_TEXT(ZONE,2)(1:L2),ZID

            ENDIF
         ENDDO

      close(444)

      DEALLOCATE(POINT_COORDS)
      DEALLOCATE(POINT_ZONE_INFO)
      DEALLOCATE(FACE_ZONE_INFO)
      DEALLOCATE(BC_LABEL_TEXT)
      DEALLOCATE(BC_ASSIGNED)

      RETURN

!======================================================================
!     HERE IF AN ERROR OCCURED OPENNING/READING THE FILE
!======================================================================
!
 910  CONTINUE
      WRITE (*, 1500)
      CALL MFIX_EXIT(myPE)
 920  CONTINUE
      WRITE (*, 1600)
      CALL MFIX_EXIT(myPE)
 930  CONTINUE
      WRITE (*, 1700)
      CALL MFIX_EXIT(myPE)

 1000 FORMAT(1X,I4,7X,A8,I8,1X,A20,1X,A20)
 1010 FORMAT(1X,I4,5X,A20,1X,A20)
 1020 FORMAT(5X,I3,2X,3(I10,2X))
!
 1500 FORMAT(/1X,70('*')//' From: GET_STL_DATA',/' Message: ',&
      'Unable to open stl file',/1X,70('*')/)
 1600 FORMAT(/1X,70('*')//' From: GET_STL_DATA',/' Message: ',&
      'Error while reading stl file',/1X,70('*')/)
 1700 FORMAT(/1X,70('*')//' From: GET_STL_DATA',/' Message: ',&
      'End of file reached while reading stl file',/1X,70('*')/)
 2000 FORMAT(1X,A)
 2010 FORMAT(1X,A,I4,A)
 3000 FORMAT(1X,A,'(',F10.4,';',F10.4,';',F10.4,')')
 4000 FORMAT(1X,A,F10.4,' to ',F10.4)
 5000 FORMAT(1X,A,F10.4)
 6000 FORMAT(A,1X,A,'_',I4.4)
      END SUBROUTINE GET_MSH_DATA


      SUBROUTINE SKIP(FILE_UNIT,N_SKIP)
        IMPLICIT NONE
        INTEGER, INTENT(IN) ::FILE_UNIT,N_SKIP
        INTEGER :: I
        DO I = 1,N_SKIP
           READ(FILE_UNIT,*)
        END DO
        RETURN
      END SUBROUTINE SKIP

      SUBROUTINE TEXT_HEX2INT(STRING,INT)

      CHARACTER(LEN=10)  :: INTERNAL
      CHARACTER(LEN=*)   :: STRING
      CHARACTER(LEN=10)  :: CLEANED_STRING
      INTEGER :: INT

      CLEANED_STRING = STRING
      IF(STRING(1:1)=='(') CLEANED_STRING = STRING(2:)

      WRITE(INTERNAL,fmt='(A10)') TRIM(CLEANED_STRING)
      READ(INTERNAL,FMT='(Z10)') INT

      RETURN

      END SUBROUTINE TEXT_HEX2INT

      SUBROUTINE TEXT_DEC2INT(STRING,INT)

      CHARACTER(LEN=10)  :: INTERNAL
      CHARACTER(LEN=*)   :: STRING
      CHARACTER(LEN=10)  :: CLEANED_STRING
      INTEGER :: INT

      CLEANED_STRING = STRING
      IF(STRING(1:1)=='(') CLEANED_STRING = STRING(2:)

      WRITE(INTERNAL,fmt='(A10)') TRIM(CLEANED_STRING)
      READ(INTERNAL,FMT='(I10)') INT

      RETURN

      END SUBROUTINE TEXT_DEC2INT


!vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvC
!                                                                      C
!  Module name: GET_STL_DATA                                           C
!  Purpose: reads face verticesa and normal vectors from an STL file   C
!                                                                      C
!  Author: Jeff Dietiker                              Date: 30-JAN-09  C
!  Reviewer:                                          Date: **-***-**  C
!                                                                      C
!  Revision Number:                                                    C
!  Purpose:                                                            C
!  Author:                                            Date: dd-mmm-yy  C
!  Reviewer:                                          Date: dd-mmm-yy  C
!                                                                      C
!  Literature/Document References:                                     C
!                                                                      C
!  Variables referenced:                                               C
!                                                                      C
!  Variables modified:                                                 C
!                                                                      C
!  Local variables:                                                    C
!                                                                      C
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^C
!
      SUBROUTINE GET_STL_DATA

!-----------------------------------------------
!   M o d u l e s
!-----------------------------------------------

      USE bc
      USE compar
      USE constant
      USE exit, only: mfix_exit
      USE fldvar
      USE funits
      USE mpi_utility
      USE param
      USE param1
      USE physprop
      USE progress_bar
      USE quadric
      USE run
      USE rxns
      USE scalars
      USE stl
      USE vtk
      IMPLICIT NONE

      INTEGER :: NN,IGNORED_FACETS
      LOGICAL :: PRESENT,KEEP_READING,IGNORE_CURRENT_FACET
      DOUBLE PRECISION ::v1x,v1y,v1z
      DOUBLE PRECISION ::v2x,v2y,v2z
      DOUBLE PRECISION ::v3x,v3y,v3z
      DOUBLE PRECISION ::x12,y12,z12,x13,y13,z13,dp,d12,d13
      DOUBLE PRECISION ::cos_angle,cos_small_angle
      DOUBLE PRECISION ::n1,n2,n3,NORM
      DOUBLE PRECISION ::ABSTRANS
      CHARACTER(LEN=32) ::TEST_CHAR,BUFF_CHAR
      CHARACTER(LEN=255) ::geometryfile(0:DIMENSION_BC)

      INTEGER :: BCV,NUMBER_OF_GEOMETRY_FILES,NUMBER_OF_BC_PATCHES
      INTEGER :: BC_PATCH(0:DIMENSION_BC),L2,NF1,NF2
      LOGICAL :: BC_PATCH_FOUND_IN_STL(DIMENSION_BC)

      CHARACTER(LEN=100) :: FNAME
      integer :: stl_unit, nf

      BC_PATCH_FOUND_IN_STL = .FALSE.

      geometryfile(0) = 'geometry.stl'
      NUMBER_OF_GEOMETRY_FILES = 0
      NUMBER_OF_BC_PATCHES     = 0

!     DETERMINE WHICH BOUNDARY CONDITIONS NEED STL FILE

      IF(MyPE == PE_IO) THEN
         WRITE(*,100)'From Get_Stl_Data: Analysing BCs in mfix.dat...'
         WRITE(*,120)'BC_ID','BC_TYPE'
      ENDIF
      DO BCV = 1, DIMENSION_BC

         IF(IS_CG(BC_TYPE_ENUM(BCV))) THEN

            NUMBER_OF_GEOMETRY_FILES = NUMBER_OF_GEOMETRY_FILES + 1
            NUMBER_OF_BC_PATCHES     = NUMBER_OF_BC_PATCHES + 1


            BC_PATCH(NUMBER_OF_GEOMETRY_FILES) = BCV
            WRITE(geometryfile(NUMBER_OF_GEOMETRY_FILES),200) 'geometry_',BCV

            IF(MyPE == PE_IO) WRITE(*,130)BCV,BC_TYPE(BCV)

         ENDIF
      ENDDO

      IF(MyPE == PE_IO) WRITE(*,110)'Number of CG BCs in mfix.dat = ',NUMBER_OF_BC_PATCHES

100  FORMAT(1X,A)
110  FORMAT(1X,A,I6)
120  FORMAT(1X,A6,4X,A7)
130  FORMAT(1X,I6,4X,A6)
140  FORMAT(1X,A,I6,A)
200  FORMAT(A,I4.4,".stl")

! VERIFY THAT THERE IS AT LEAST ONE STL FILE TO READ

      IF(NUMBER_OF_BC_PATCHES==0) THEN
         IF(MyPE == PE_IO) THEN
            WRITE(*,100) 'ERROR: NO CARTESIAN GRID BOUNDARY CONDITION SPECIFIED.'
            WRITE(*,100) 'AT LEAST ONE BC_TYPE MUST START WITH CG (FOR EXAMPLE CG_NSW)'
            WRITE(*,100) 'RUN ABORTED'
            CALL MFIX_EXIT(MYPE)
         ENDIF

      ELSEIF(NUMBER_OF_BC_PATCHES==1) THEN

         INQUIRE(FILE='geometry.stl',EXIST=PRESENT)
         IF(PRESENT) THEN

!            IF(STL_BC_ID==BC_PATCH(1)) THEN
               IF(MyPE == PE_IO) THEN
                  WRITE(*,110) 'The file geometry.stl exists and the following  BC patch was found: ', BC_PATCH(1)
               ENDIF

               NF1 = 1
               NF2 = 1
               geometryfile(NF1)='geometry.stl'

!            ENDIF
         ENDIF

      ELSE  ! More than one CG BC type
         INQUIRE(FILE='geometry.stl',EXIST=PRESENT)
         IF(PRESENT) THEN
            IF(MyPE == PE_IO) THEN
               WRITE(*,100) 'The file geometry.stl exists and several CG BC types are defined.'
               WRITE(*,100) 'All BC patches will be read from geometry.stl.'
            ENDIF

            geometryfile(0)='geometry.stl'
            NF1 = 0
            NF2 = 0                       ! This invokes a special treatment
                                          ! to reading multiple solids

         ELSE

            NF1 = 1
            NF2 = NUMBER_OF_GEOMETRY_FILES
            IF(MyPE == PE_IO) THEN
               WRITE(*,100) 'The file geometry.stl does not exist and several CG_BC types are defined.'
               WRITE(*,100) 'Each BC patch will be read from geometry_BCID.stl.'
               WRITE(*,100) 'where BCID is 4-paded integer'
            ENDIF

         ENDIF



      ENDIF


! START READING EACH STL FILE, ONE FOR EACH BC_TYPE

      N_FACETS = 0
      IGNORED_FACETS = 0


      DO NN = NF1, NF2

         IF(MyPE == PE_IO) WRITE(*,2000) 'Reading geometry from '//TRIM(geometryfile(NN))//' ...'

         INQUIRE(FILE=TRIM(geometryfile(NN)),EXIST=PRESENT)
         IF(.NOT.PRESENT) THEN
            IF(MyPE == PE_IO) THEN
               WRITE(*,"('(PE ',I3,'): input data file, ',A11,' is missing: run aborted')") &
               myPE,TRIM(geometryfile(NN))
            ENDIF
            CALL MFIX_EXIT(MYPE)
         ENDIF


!
!     OPEN geometry.stl ASCII FILE
!
         OPEN(UNIT=333, FILE=TRIM(geometryfile(NN)), STATUS='OLD', ERR=910,CONVERT='BIG_ENDIAN')

         IF(MyPE == PE_IO) WRITE(*,2000)'STL file opened. Starting reading data...'

         KEEP_READING = .TRUE.

         DO WHILE(KEEP_READING)

            READ(333,*,ERR=920,END=930) TEST_CHAR
!            print *,'TEST_CHAR=',TEST_CHAR
            IF(TRIM(TEST_CHAR) == 'solid'.AND.NN==0) THEN

               BACKSPACE(333)

               READ(333,*,ERR=920,END=930) BUFF_CHAR,BUFF_CHAR

               L2=LEN(TRIM(BUFF_CHAR))-3

               READ(BUFF_CHAR(L2:L2+4),fmt='(I4.4)') BC_PATCH(NN)

               IF(MyPE == PE_IO)  WRITE(*,140) 'Found BC patch #', BC_PATCH(NN), ' in STL file.'

               IF(.NOT.IS_CG(BC_TYPE_ENUM(BC_PATCH(NN)))) THEN
                  IF(MyPE == PE_IO)  THEN
                     WRITE(*,110) 'This BC patch does not mach a CG BC in mfix.dat:',BC_PATCH(NN)
                     WRITE(*,100)'Please Correct mfix.dat and/or stl file amd try again'
                     CALL MFIX_EXIT(myPE)
                  ENDIF
               ENDIF

               BC_PATCH_FOUND_IN_STL(BC_PATCH(NN)) = .TRUE.

            ELSEIF(TRIM(TEST_CHAR) == 'facet') THEN

               BACKSPACE(333)
               IGNORE_CURRENT_FACET = .FALSE.

               READ(333,*,ERR=920,END=930) BUFF_CHAR,BUFF_CHAR,N1,N2,N3  ! Read unit normal vector
               READ(333,*,ERR=920,END=930)
               READ(333,*,ERR=920,END=930) BUFF_CHAR, V1x,V1y,V1z
               READ(333,*,ERR=920,END=930) BUFF_CHAR, V2x,V2y,V2z
               READ(333,*,ERR=920,END=930) BUFF_CHAR, V3x,V3y,V3z

               N1 = N1 * OUT_STL_VALUE  ! Reverse unit vector if needed (this will switch fluid and blocked cells)
               N2 = N2 * OUT_STL_VALUE
               N3 = N3 * OUT_STL_VALUE

               x12 = V2x - V1x
               y12 = V2y - V1y
               z12 = V2z - V1z

               x13 = V3x - V1x
               y13 = V3y - V1y
               z13 = V3z - V1z


               dp  = x12*x13 + y12*y13 + z12*z13
               d12 = sqrt(x12**2+y12**2+z12**2)
               d13 = sqrt(x13**2+y13**2+z13**2)

               IF((d12*d13)>TOL_STL) THEN
                  cos_angle = dp/(d12*d13)
               ELSE
                  cos_angle = ONE
               ENDIF

               cos_small_angle = dcos(STL_SMALL_ANGLE / 180.0 * PI)

               IF(DABS(cos_angle)>cos_small_angle) THEN
                  IGNORE_CURRENT_FACET = .TRUE.    ! Ignore small facets
               ENDIF

               NORM = sqrt(N1**2+N2**2+N3**2)

               IF(NORM>TOL_STL) THEN
                  N1 = N1 /NORM
                  N2 = N2 /NORM
                  N3 = N3 /NORM
               ELSE
                  IGNORE_CURRENT_FACET = .TRUE.  ! Ignore facets with zero normal vector
               ENDIF


               IF(IGNORE_CURRENT_FACET) THEN
                  IGNORED_FACETS = IGNORED_FACETS + 1
               ELSE                                                      ! Save vertex coordinates for valid facets
                                                                         ! and performs translation
                  N_FACETS = N_FACETS + 1

                  NORM_FACE(1,N_FACETS) = N1
                  NORM_FACE(2,N_FACETS) = N2
                  NORM_FACE(3,N_FACETS) = N3

                  VERTEX(1,1,N_FACETS) = SCALE_STL*V1x + TX_STL
                  VERTEX(1,2,N_FACETS) = SCALE_STL*V1y + TY_STL
                  VERTEX(1,3,N_FACETS) = SCALE_STL*V1z + TZ_STL

                  VERTEX(2,1,N_FACETS) = SCALE_STL*V2x + TX_STL
                  VERTEX(2,2,N_FACETS) = SCALE_STL*V2y + TY_STL
                  VERTEX(2,3,N_FACETS) = SCALE_STL*V2z + TZ_STL

                  VERTEX(3,1,N_FACETS) = SCALE_STL*V3x + TX_STL
                  VERTEX(3,2,N_FACETS) = SCALE_STL*V3y + TY_STL
                  VERTEX(3,3,N_FACETS) = SCALE_STL*V3z + TZ_STL

                  BC_ID_STL_FACE(N_FACETS) = BC_PATCH(NN)


               ENDIF

!            ELSEIF(TRIM(TEST_CHAR) == 'endsolid') THEN

!               KEEP_READING = .FALSE.

            ENDIF

         ENDDO


930      IF(MyPE == PE_IO)  WRITE(*,100) 'Done reading file.'

         CLOSE(333)




      ENDDO


      IF(myPE==0.AND.NF2==0) THEN
         DO NN = 1,NUMBER_OF_BC_PATCHES

            IF(.NOT.BC_PATCH_FOUND_IN_STL(BC_PATCH(NN))) THEN
               WRITE (*, 140)'Did not find BC patch: ',BC_PATCH(NN) , ' in stl file'
               WRITE(*,100)'Please correct mfix.dat and/or stl file amd try again'
               CALL MFIX_EXIT(myPE)
            ENDIF

         ENDDO
      ENDIF





      XMIN_STL = MINVAL(VERTEX(:,1,1:N_FACETS))
      XMAX_STL = MAXVAL(VERTEX(:,1,1:N_FACETS))
      YMIN_STL = MINVAL(VERTEX(:,2,1:N_FACETS))
      YMAX_STL = MAXVAL(VERTEX(:,2,1:N_FACETS))
      ZMIN_STL = MINVAL(VERTEX(:,3,1:N_FACETS))
      ZMAX_STL = MAXVAL(VERTEX(:,3,1:N_FACETS))

      IF(MyPE == PE_IO) THEN
         WRITE(*,2000)'STL file(s) successfully read.'
         WRITE(*,110)'Total number of facets read =',N_FACETS + IGNORED_FACETS
         WRITE(*,110)'Number of valid facets      =',N_FACETS
         WRITE(*,110)'Number of ignored facets    =',IGNORED_FACETS
         WRITE(*,100)'Geometry range from stl file:'
         IF(SCALE_STL/=ONE) THEN
            WRITE(*,5000)'Scaling factor:',SCALE_STL
         ENDIF
         ABSTRANS = dabs(TX_STL)+dabs(TY_STL)+dabs(TZ_STL)
         IF(ABSTRANS>TOL_STL) THEN
            WRITE(*,3000)'Translation vector (X,Y,Z)=',TX_STL,TY_STL,TZ_STL
         ENDIF
         WRITE(*,4000)'x-range = ', XMIN_STL,XMAX_STL
         WRITE(*,4000)'y-range = ', YMIN_STL,YMAX_STL
         WRITE(*,4000)'z-range = ', ZMIN_STL,ZMAX_STL
         WRITE(*,4000)''
      ENDIF

      XMIN_STL = XMIN_STL - 10.0*TOL_STL
      XMAX_STL = XMAX_STL + 10.0*TOL_STL
      YMIN_STL = YMIN_STL - 10.0*TOL_STL
      YMAX_STL = YMAX_STL + 10.0*TOL_STL
      ZMIN_STL = ZMIN_STL - 10.0*TOL_STL
      ZMAX_STL = ZMAX_STL + 10.0*TOL_STL



!      IF(XMIN_STL<ZERO) XMIN_STL=ZERO
!      IF(XMAX_STL>XLENGTH) XMAX_STL=XLENGTH
!      IF(YMIN_STL<ZERO) YMIN_STL=ZERO
!      IF(YMAX_STL>YLENGTH) YMAX_STL=YLENGTH
!      IF(ZMIN_STL<ZERO) ZMIN_STL=ZERO
!      IF(ZMAX_STL>ZLENGTH) ZMAX_STL=ZLENGTH

      IF(mype.eq.pe_io.and..false.) then
         WRITE(fname,'(A,"_FACETS_READ", ".stl")') &
         TRIM(RUN_NAME)
         open(stl_unit, file = fname, form='formatted',convert='big_endian')
         write(stl_unit,*)'solid vcg'


         do nf = 1, n_facets

            write(stl_unit,*) '   facet normal ', NORM_FACE(:,NF)
            write(stl_unit,*) '      outer loop'
            write(stl_unit,*) '         vertex ', VERTEX(1,1:3,NF)
            write(stl_unit,*) '         vertex ', VERTEX(2,1:3,NF)
            write(stl_unit,*) '         vertex ', VERTEX(3,1:3,NF)
            write(stl_unit,*) '      endloop'
            write(stl_unit,*)'   endfacet'
         enddo


         write(stl_unit,*)'endsolid vcg'
         close(stl_unit, status = 'keep')
         IF(MyPE == PE_IO) THEN
            WRITE(*,100) 'The file FACETS_READ.stl was sucessfully written.'
            WRITE(*,100) 'and is provided for convenience (it is not used).'
         ENDIF

      endif

      RETURN

!======================================================================
!     HERE IF AN ERROR OCCURED OPENNING/READING THE FILE
!======================================================================
!
 910  CONTINUE
      WRITE (*, 1500)
      CALL MFIX_EXIT(myPE)
 920  CONTINUE
      WRITE (*, 1600)
      CALL MFIX_EXIT(myPE)
! 930  CONTINUE
!     WRITE (*, 1700)
!     CALL MFIX_EXIT(myPE)
!
 1500 FORMAT(/1X,70('*')//' From: GET_STL_DATA',/' Message: ',&
      'Unable to open stl file',/1X,70('*')/)
 1600 FORMAT(/1X,70('*')//' From: GET_STL_DATA',/' Message: ',&
      'Error while reading stl file',/1X,70('*')/)
 1700 FORMAT(/1X,70('*')//' From: GET_STL_DATA',/' Message: ',&
      'End of file reached while reading stl file',/1X,70('*')/)
 2000 FORMAT(1X,A)
 2010 FORMAT(1X,A,I4,A)
 3000 FORMAT(1X,A,'(',F10.4,';',F10.4,';',F10.4,')')
 4000 FORMAT(1X,A,F10.4,' to ',F10.4)
 5000 FORMAT(1X,A,F10.4)
      END SUBROUTINE GET_STL_DATA

!vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvC
!                                                                      C
!  Module name: EVAL_STL_FCT_AT                                        C
!  Purpose: Assigns a value to f_stl at any NODE of cell IJK           C
!                                                                      C
!  Author: Jeff Dietiker                              Date: 30-JAN-09  C
!  Reviewer:                                          Date: **-***-**  C
!                                                                      C
!  Revision Number:                                                    C
!  Purpose:                                                            C
!  Author:                                            Date: dd-mmm-yy  C
!  Reviewer:                                          Date: dd-mmm-yy  C
!                                                                      C
!  Literature/Document References:                                     C
!                                                                      C
!  Variables referenced:                                               C
!                                                                      C
!  Variables modified:                                                 C
!                                                                      C
!  Local variables:                                                    C
!                                                                      C
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^C
!
      SUBROUTINE EVAL_STL_FCT_AT(TYPE_OF_CELL,IJK,NODE,f_stl,CLIP_FLAG,BCID)

!-----------------------------------------------
!   M o d u l e s
!-----------------------------------------------

      USE param
      USE param1
      USE physprop
      USE fldvar
      USE run
      USE scalars
      USE funits
      USE rxns
      USE compar
      USE mpi_utility
      USE progress_bar
!      USE quadric
      USE cutcell
      USE stl
      USE functions
      IMPLICIT NONE

      INTEGER :: BCID
      LOGICAL :: CLIP_FLAG
      DOUBLE PRECISION :: f_stl

      CHARACTER (LEN=*) :: TYPE_OF_CELL
      INTEGER :: IJK,IJKC,NODE

      IF(NODE==15) print*,'Warning: eval stl at node 15'

      IF(N_FACETS < 1) RETURN

      f_stl = UNDEFINED

      IJKC = IJK_OF_NODE(NODE)

      IF(IJKC<1.OR.IJKC>DIMENSION_3) THEN

!         print*,'myPE        =',myPE
!         print*,'DIMENSION_3 =',DIMENSION_3
!         print*,'IJKC        =',IJKC
!         print*,'IJK         =',IJK
!         print*,'I,J,K       =',I_OF(IJK),J_OF(IJK),K_OF(IJK)
!         print*,'NODE        =',NODE

!     Leave f_stl as undefined if we are out of bounds
!     This can happen at I=1 and NODE=4 for example
         RETURN

      ENDIF

!!      IF(NODE/=15.AND.NODE/=0) THEN
!!         IF(SNAP(IJKC)) THEN
!!            f_stl = ZERO
!!!            print*,'stlfc snapped=',IJKC,NODE,F_AT(IJKC)
!!            RETURN
!!         ENDIF
!!      ENDIF


      f_stl = F_AT(IJKC)

      RETURN


      CLIP_FLAG = .TRUE.


      RETURN


      END SUBROUTINE EVAL_STL_FCT_AT


!vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvC
!                                                                      C
!  Module name: intersect_line_with_facet                              C
!  Purpose: Finds the intersection between a facet                     C
!           and the line (xa,ya,za) and (xb,yb,zb).                    C
!                                                                      C
!  Author: Jeff Dietiker                              Date: 21-Feb-08  C
!  Reviewer:                                          Date:            C
!                                                                      C
!  Revision Number #                                  Date: ##-###-##  C
!  Author: #                                                           C
!  Purpose: #                                                          C
!                                                                      C
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^C
  SUBROUTINE INTERSECT_LINE_WITH_FACET(xa,ya,za,xb,yb,zb,FACET,INTERSECT_FLAG,xc,yc,zc)

      USE param
      USE param1
      USE parallel
      USE constant
      USE run
      USE toleranc
      USE geometry
      USE indices
      USE compar
      USE sendrecv
      USE quadric
      USE STL

      IMPLICIT NONE
      DOUBLE PRECISION:: xa,ya,za,xb,yb,zb,xc,yc,zc
      INTEGER :: FACET
      DOUBLE PRECISION:: NFx,NFy,NFz,nabx,naby,nabz
      DOUBLE PRECISION :: dot_denom,dot_num
      DOUBLE PRECISION :: VP1Ax,VP1Ay,VP1Az
      DOUBLE PRECISION :: Px,Py,Pz
      DOUBLE PRECISION :: tt
      DOUBLE PRECISION :: d_ac,d_bc
      LOGICAL :: INSIDE_FACET,INTERSECT_FLAG


!======================================================================
! This subroutine tries to find the intersection of a line AB with one
! of the facets defined in the stl file
!
!
! 1) Verify that intersection is possible. Only facets and line AB that are
!    not parallel are acceptable candidates
! 2) Find intersection point P of line AB with plane containing the facet.
!    Valid intersection point must be between A and B to continue.
! 3) Verify that point P is inside triangular facet
!======================================================================

      INTERSECT_FLAG = .FALSE.

!======================================================================
!  Facet normal vector (normalized)
!======================================================================
      NFx = NORM_FACE(1,FACET)
      NFy = NORM_FACE(2,FACET)
      NFz = NORM_FACE(3,FACET)

!======================================================================
!  AB vector (NOT normalized)
!======================================================================
      nabx = xb - xa
      naby = yb - ya
      nabz = zb - za

      dot_denom = NFx*nabx + NFy*naby + NFz*nabz
!======================================================================
! 1) Verify that intersection is possible. Only facets and line AB that are
!    not parallel are acceptable candidates
!======================================================================
      IF(dabs(dot_denom)<TOL_STL) THEN

         INTERSECT_FLAG = .FALSE.              ! No intersection (facet nornal
                                               ! and AB are perpendicular
         RETURN

      ELSE

!======================================================================
! 2) Find intersection point P of line AB with plane containing the facet
!    Line AB is parametrized with parameter t (from t=0 at A to t=1 at B)
!======================================================================
         VP1Ax = VERTEX(1,1,FACET) - xa
         VP1Ay = VERTEX(1,2,FACET) - ya
         VP1Az = VERTEX(1,3,FACET) - za

         dot_num = NFx*VP1Ax + NFy*VP1Ay + NFz*VP1Az

         tt = dot_num / dot_denom

!======================================================================
! 3) Verify that point P is inside triangular facet
!    Facet is parametrized with (u,v), a point is inside triange if:
!    u   >= 0  , and
!    v   >= 0  , and
!    u+v <= 1
!======================================================================
         IF((tt>=ZERO).AND.(tt<=ONE)) THEN       ! Intersection between A and B
                                               ! Now test if intersection point is inside triangle

            Px = xa + tt*nabx
            Py = ya + tt*naby
            Pz = za + tt*nabz

            CALL IS_POINT_INSIDE_FACET(Px,Py,Pz,FACET,INSIDE_FACET)

            IF(INSIDE_FACET) THEN
               INTERSECT_FLAG = .TRUE.              ! Valid intersection
               xc = Px                              ! point P is inside triangle)
               yc = Py
               zc = Pz
            ELSE
               INTERSECT_FLAG = .FALSE.             ! Invalid intersection
               RETURN                               ! point P is outside triangle)
            ENDIF

         ELSE

            INTERSECT_FLAG = .FALSE.           ! No intersection between A and B
            RETURN

         ENDIF

      ENDIF


      d_ac = sqrt((xc-xa)**2 + (yc-ya)**2 + (zc-za)**2)
      d_bc = sqrt((xc-xb)**2 + (yc-yb)**2 + (zc-zb)**2)


      IF(d_ac<TOL_STL.OR.d_bc<TOL_STL) THEN
         INTERSECT_FLAG = .FALSE.             ! Exclude corner intersection
      ENDIF


 1000 FORMAT(A,3(2X,G12.5))


      RETURN

      END SUBROUTINE INTERSECT_LINE_WITH_FACET

!vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvC
!                                                                      C
!  Module name: IS_POINT_INSIDE_FACET                                  C
!  Purpose: Verifies that point P is inside facet                      C
!                                                                      C
!  Author: Jeff Dietiker                              Date: 21-Feb-08  C
!  Reviewer:                                          Date:            C
!                                                                      C
!  Revision Number #                                  Date: ##-###-##  C
!  Author: #                                                           C
!  Purpose: #                                                          C
!                                                                      C
!^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^C
  SUBROUTINE IS_POINT_INSIDE_FACET(Px,Py,Pz,FACET,INSIDE_FACET)

      USE param
      USE param1
      USE parallel
      USE constant
      USE run
      USE toleranc
      USE geometry
      USE indices
      USE compar
      USE sendrecv
      USE quadric
      USE STL

      IMPLICIT NONE
      INTEGER :: FACET,VV
      DOUBLE PRECISION :: NFx,NFy,NFz
      DOUBLE PRECISION :: Px,Py,Pz,V0x,V0y,V0z,V1x,V1y,V1z,V2x,V2y,V2z
      DOUBLE PRECISION :: dot00,dot01,dot02,dot11,dot12,dot_check
      DOUBLE PRECISION :: Inv_denom
      DOUBLE PRECISION :: u,v
      LOGICAL :: U_POSITIVE,V_POSITIVE,UPVL1,INSIDE_FACET

      DOUBLE PRECISION :: Vx,Vy,Vz
      DOUBLE PRECISION :: D(3),MINVAL_D,DH

!======================================================================
!  If point P is very close to one of the Facet vertices,
!  consider that P belongs to facet, and return.
!======================================================================
         DO VV = 1,3
            Vx = VERTEX(VV,1,FACET)
            Vy = VERTEX(VV,2,FACET)
            Vz = VERTEX(VV,3,FACET)
            D(VV) = sqrt((Px - Vx)**2 + (Py - Vy)**2 + (Pz - Vz)**2 )
         ENDDO

         MINVAL_D = MINVAL(D)

         IF(MINVAL_D < TOL_STL) THEN
            INSIDE_FACET = .TRUE.
            RETURN
         ENDIF

!======================================================================
!  Facet normal vector (normalized)
!======================================================================
      NFx = NORM_FACE(1,FACET)
      NFy = NORM_FACE(2,FACET)
      NFz = NORM_FACE(3,FACET)

!======================================================================
! This subroutine verifies that point P is inside triangular facet
! Facet is parametrized with (u,v), a point is inside triange if:
! u   >= 0  , and
! v   >= 0  , and
! u+v <= 1
!======================================================================

      V0x = VERTEX(2,1,FACET) - VERTEX(1,1,FACET)
      V0y = VERTEX(2,2,FACET) - VERTEX(1,2,FACET)
      V0z = VERTEX(2,3,FACET) - VERTEX(1,3,FACET)

      V1x = VERTEX(3,1,FACET) - VERTEX(1,1,FACET)
      V1y = VERTEX(3,2,FACET) - VERTEX(1,2,FACET)
      V1z = VERTEX(3,3,FACET) - VERTEX(1,3,FACET)

      V2x = Px - VERTEX(1,1,FACET)
      V2y = Py - VERTEX(1,2,FACET)
      V2z = Pz - VERTEX(1,3,FACET)

      dot_check = NFx*V2x + NFy*V2y + NFz*V2z

!      IF(dabs(dot_check)>TOL_STL_DP) THEN          ! reject points that do not
!         INSIDE_FACET = .FALSE.                 ! belong to plane containing facet
!         RETURN
!      ENDIF

      DH = NFx * V2x + NFy * V2y + NFz * V2z

      IF(dabs(DH)>TOL_STL_DP) THEN          ! reject points that do not
         INSIDE_FACET = .FALSE.                 ! belong to plane containing facet
         RETURN
      ENDIF

      dot00 = V0x*V0x + V0y*V0y + V0z*V0z
      dot01 = V0x*V1x + V0y*V1y + V0z*V1z
      dot02 = V0x*V2x + V0y*V2y + V0z*V2z
      dot11 = V1x*V1x + V1y*V1y + V1z*V1z
      dot12 = V1x*V2x + V1y*V2y + V1z*V2z

      Inv_denom = ONE / (dot00*dot11 - dot01*dot01)

      u = (dot11*dot02 - dot01*dot12) * Inv_denom
      v = (dot00*dot12 - dot01*dot02) * Inv_denom

      U_POSITIVE = (u>=-TOL_STL)
      V_POSITIVE = (v>=-TOL_STL)
      UPVL1 = ((u+v)<=ONE+TOL_STL)

      INSIDE_FACET = (U_POSITIVE.AND.V_POSITIVE.AND.UPVL1)

      RETURN

      END SUBROUTINE IS_POINT_INSIDE_FACET
